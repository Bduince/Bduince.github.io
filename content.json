{"meta":{"title":"Bduince's Blog","subtitle":null,"description":null,"author":"thanks to John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"PAT 1003","slug":"PAT","date":"2017-03-22T12:18:21.000Z","updated":"2017-03-22T12:39:11.189Z","comments":true,"path":"2017/03/22/PAT/","link":"","permalink":"http://yoursite.com/2017/03/22/PAT/","excerpt":"题目As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an","text":"题目As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output2 4 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include&lt;string.h&gt;using namespace std;//目标：void dfs(int from,int len,int helpers);int N,M,C1,C2;int maxhp=0,cnt=0,shpath=-1; int hpers[501]; int vst[501]; int road[501][501];int main()&#123; int i,j; int c1,c2,len; cin&gt;&gt;N&gt;&gt;M&gt;&gt;C1&gt;&gt;C2; for(i=0;i&lt;N;++i)&#123; cin&gt;&gt;hpers[i]; vst[i]=0; for(j=0;j&lt;N;++j)&#123; road[i][j]=-1; road[j][i]=-1; &#125; &#125; for(i=0;i&lt;M;++i)&#123; cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;len; road[c1][c2]=len; road[c2][c1]=len; &#125; vst[C1]=1; dfs(C1,0,hpers[C1]); cout&lt;&lt;cnt&lt;&lt;\" \"&lt;&lt;maxhp; return 0; &#125;void dfs(int from,int len, int helpers)&#123; int i; if(shpath!=-1&amp;&amp;len&gt;shpath)&#123; //当前搜素路长于最短路，退回上一结点 return; &#125; if(from==C2)&#123; //找到C2 if(len&lt;shpath||shpath==-1)//当前为第一次搜索，或当前搜索结果为最短路 ，必须先判断len&lt;shpath,再判断shpath==-1反过来则出错 &#123; shpath = len;//更新最短路 maxhp = helpers; //更新最大人数 cnt=1;//由于当前路为最短路，清空此前统计 &#125; else if(len==shpath)&#123;//找到复数条最短路 cnt++; if(helpers&gt;maxhp) maxhp = helpers; &#125; &#125; for(i=0;i&lt;N;++i)&#123; if(vst[i]==0&amp;&amp;road[from][i]!=-1)&#123; vst[i]=1; dfs(i,len+road[from][i],helpers+hpers[i]); vst[i]=0; &#125; &#125;&#125;","categories":[],"tags":[{"name":"PAT","slug":"PAT","permalink":"http://yoursite.com/tags/PAT/"}]},{"title":"动态规划入门","slug":"动态规划","date":"2017-03-19T14:01:24.000Z","updated":"2017-03-22T12:32:02.657Z","comments":true,"path":"2017/03/19/动态规划/","link":"","permalink":"http://yoursite.com/2017/03/19/动态规划/","excerpt":"思想 将原问题拆分为子问题，解决子问题后，组合解决原问题。","text":"思想 将原问题拆分为子问题，解决子问题后，组合解决原问题。为了方便理解，举例子如下：123约束： 已知每个宝箱中可以获得的钥匙数量 已知开启宝箱需要耗费的钥匙数量原问题：现在有10个箱子和20把万能钥匙，问最多可以得到多少枚金币。 我们当然可以用穷举的方法找出可以获得的金币的最大数量，但这样一来，每个箱子有2种状态（打开和不打开），一共有10个箱子，则最多需要2^10次计算，算法的时间复杂度为O(2^n)。 让我们换一种思路，每个箱子有打开和不打开两种状态，那么只要考虑“打开第一个箱子后，最多可以获得多少金币”与“不打开第一个箱子，最多可以获得多少金币”这两种情况，很明显其中金币数较多的那个就是我们需要的方案。假设开启第一个箱子需要3把万能钥匙，箱子中有5个金币，则原问题可以转化为两个一级子问题：12一级子问题1：（假设开启第一个箱子）现有9个箱子和17把万能钥匙以及5个金币，问最多可获得多少金币一级子问题2：（假设不开启第一个箱子）现在有10个箱子和20把万能钥匙，问最多可获得多少金币 而对于子问题1，我们可以以同样的思路将之转化为两个二级子问题，我们假设打开第二个箱子需要2把钥匙，可以获得1枚金币，则一级子问题1可转化为：12二级子问题1：（假设不开启第二个箱子）现有9个箱子，17把万能钥匙，5枚金币，问最多可获得多少金币二级子问题2：（假设开启第二个箱子）现有9个箱子，15把万能钥匙，6枚金币，问最多可获得多少金币 可以看到，只要这两个二级子问题被解决，我们就可以解决一级子问题1，类似的，一级子问题2也可以作如上拆分。那么，这样的算法其复杂度是多少呢？可以知道，按这样拆分下去，最后一层有2^9个子问题，最终算下来复杂度还是O(2^n)，这样一来问题的规模似乎并没有被减少，这是因为当中存在大量的重复计算。比如在上面的例子中，一级子问题1和二级子问题1是相同的状态，都是9个箱子，17把万能钥匙，根本没有必要计算两遍，因此我们可以使用一个记事本，将我们算过的状态给存储下来，也就是说在碰到一级子问题1的时候我们就将这个问题记下来，而后解决二级子问题1的时候就直接从记事本中将答案取出。可以看到，通过这样的方法，最多只需要计算200次就可以找到最多的金币数量，也就是说空间复杂度从O(2^n)降低到了O(nm)。 但与之相对的，空间复杂度变成了O(nm)，那么有没有什么方法可以降低算法的空间复杂度，减少存储的开销呢？我们发现，是否打开第一个箱子，只需要知道打开第二个箱子最多可获得多少金币，不打开第二个箱子最多可获得多少金币，而与其他箱子是否打开无关，也就是说我们并不需要记录下所有的200次计算的结果，而只需要记录下一级的两个结果就可以了，于是可以把空间复杂度降低到O(2m)，由于常数没有意义，即降低到O(m) 特征 无后效性即这一阶段的决策对下一阶段无影响 去冗余或者说用空间换时间，通过一个记事簿将计算结果记录下来，减少重复计算 举例 问题： leetcode 62 A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? 递归解法（暴力搜索）12345678910111213class Solution &#123;public: int solve(int m, int n)&#123; if(n&lt;0||m&lt;0) return 0; if(m==0&amp;&amp;n==0) return 1; if(m==1||n==1) return 1; return solve(m-1,n) + solve(m, n-1); &#125; int uniquePaths(int m, int n) &#123; return solve(m,n); &#125;&#125;; 动态规划(递归）经测试可知上述代码已经可以解决问题，但当棋盘较大时由于时间复杂度过大，会导致超时，于是我们增加一个记事簿将已经算过的情况记下，在碰到时跳过。1234567891011121314151617class Solution &#123;public: int vec[101][101]; int solve(int m, int n)&#123; if(n&lt;0||m&lt;0) return 0; if(m==0&amp;&amp;n==0) return 1; if(m==1||n==1) return 1; if(vec[m][n]&gt;0)&#123; return vec[m][n]; &#125; vec[m][n] = solve(m-1,n) + solve(m, n-1); return vec[m][n]; &#125; int uniquePaths(int m, int n) &#123; return solve(m,n); &#125;&#125;; 动态规划(递推)当写出递归程序时，其实已经得到了状态转移方程，据此可以很容易地写出递推式：12345678910111213141516class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; vec(m, vector&lt;int&gt; (n, 1)); for(int i = 1; i&lt;m; ++i) &#123; for(int j = 1; j &lt; n; ++j) &#123; vec[i][j] = vec[i-1][j] + vec[i][j-1]; &#125; &#125; return vec[m-1][n-1]; &#125;&#125;; 优化 为了进一步降低动态规划算法的空间复杂度，可以使用一些小技巧。 滚动数组可以看到对于每一个状态vec[i] [j]，其结果只和vec[i-1] [j]与vec[i] [j-1]相关，即在计算时需要记录的中间结果只有这两个值，而可以省略其他结果。得到如下代码：123456789101112131415161718class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; vec(2, vector&lt;int&gt; (n, 1)); for(int i = 1; i&lt;m; ++i) &#123; for(int j = 1; j &lt; n; ++j) &#123; vec[i%2][j] = vec[(i-1)%2][j] + vec[i%2][j-1]; &#125; &#125; return vec[(m-1)%2][n-1]; &#125;&#125;; 可以看到空间复杂度降低到O(m) 状态压缩将bool值转成整数保存 其他升维，四边形不等式，单调性","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Markdown语法简介","slug":"Markdown语法简介","date":"2017-03-19T04:02:47.172Z","updated":"2017-03-19T08:19:18.047Z","comments":true,"path":"2017/03/19/Markdown语法简介/","link":"","permalink":"http://yoursite.com/2017/03/19/Markdown语法简介/","excerpt":"本文旨在方便自己以后忘了怎么用markdown写东西时查阅，内容参考自网络。","text":"本文旨在方便自己以后忘了怎么用markdown写东西时查阅，内容参考自网络。 标题 标题的语法有Setext和Atx两种形式。Settxt是用底线表示的形式，利用=和-区分最高阶标题和第二阶标题。 而Atx则是用#给标题分级，有几个#就是几级。 引用 通过在段前增加&lt;来实现，在引用区域中同样可以使用Markdown其他语法 图片 将_config文件中的post_asset_folder一项的属性设置为true，这样一来在我们创建新的帖子时在source目录下会创建一个同名的文件夹，只需要将图片放入其中，然后使用！[自定义图片名]（同名文件夹/图片名.jpg）就可以将图片插入了。使用这种方法首先需要通过npm install https://github.com/CodeFalling/hexo-asset-image --save下载插件。 另一种方法 连接 一共有两种表达方式： 第一种是形如[连接名][连接地址]第二种是形如[连接名][变量名]，然后在post中任意位置加上变量赋值[变量名]: 链接地址","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}